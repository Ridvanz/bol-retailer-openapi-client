# coding: utf-8

"""
    v10 - Retailer API

    The bol.com API for retailers.  # Authentication Our API requires authentication via OAuth2. The detailed steps to authenticate are explained [here](https://api.bol.com/retailer/public/Retailer-API/authentication.html)   # Demo scenarios Our API specification includes examples of the responses you can expect. For more information as well as more examples, we refer you to the following resources:   - [Demo environment](https://api.bol.com/retailer/public/Retailer-API/demo/demo.html) - [Demo scenarios](https://api.bol.com/retailer/public/Retailer-API/demo/v10-index.html) 

    The version of the OpenAPI document: 10.x
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Offer(BaseModel):
    """
    List of offers.
    """ # noqa: E501
    offer_id: StrictStr = Field(description="Unique identifier for an offer.", alias="offerId")
    retailer_id: StrictStr = Field(description="The ID of the retailer which the offer belongs to.", alias="retailerId")
    country_code: StrictStr = Field(description="The country code.", alias="countryCode")
    best_offer: StrictBool = Field(description="Indicator if the offer is the best offer within the country for the requested EAN.", alias="bestOffer")
    price: Union[StrictFloat, StrictInt] = Field(description="The selling price to the customer of a single unit including VAT unless there is a discount. The price should always have two decimals precision.")
    fulfilment_method: StrictStr = Field(description="The fulfilment method. Fulfilled by the retailer (FBR) or fulfilled by bol.com (FBB).", alias="fulfilmentMethod")
    condition: Optional[StrictStr] = Field(default=None, description="The condition of the offered product.")
    ultimate_order_time: Optional[StrictStr] = Field(default=None, description="The time in ISO 8601 format when the ultimate order time on the day in order to comply to the maxDeliveryDate as a promise.", alias="ultimateOrderTime")
    min_delivery_date: Optional[date] = Field(default=None, description="The date at which package can be delivered to customer earliest.", alias="minDeliveryDate")
    max_delivery_date: Optional[date] = Field(default=None, description="The date at which package can be delivered to customer latest. In case of pre-orders where a specific delivery date is not available, this field will not be present.", alias="maxDeliveryDate")
    __properties: ClassVar[List[str]] = ["offerId", "retailerId", "countryCode", "bestOffer", "price", "fulfilmentMethod", "condition", "ultimateOrderTime", "minDeliveryDate", "maxDeliveryDate"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Offer from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Offer from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "offerId": obj.get("offerId"),
            "retailerId": obj.get("retailerId"),
            "countryCode": obj.get("countryCode"),
            "bestOffer": obj.get("bestOffer"),
            "price": obj.get("price"),
            "fulfilmentMethod": obj.get("fulfilmentMethod"),
            "condition": obj.get("condition"),
            "ultimateOrderTime": obj.get("ultimateOrderTime"),
            "minDeliveryDate": obj.get("minDeliveryDate"),
            "maxDeliveryDate": obj.get("maxDeliveryDate")
        })
        return _obj


